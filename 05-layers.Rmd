# Layers {#layers}

<!-- make the order of the table to be consistent with the rest of the chapter! -->

```{r, echo=FALSE}
layers_basic_df = tibble::tribble(
  ~Function, ~Element, ~Geometry,
  "tm_polygons()", "polygons (borders and fill)", "polygons",
  "tm_symbols()", "symbols", "points, polygons, and lines", 
  "tm_lines()", "lines", "lines", 
  "tm_raster()", "raster", "raster",
  "tm_text()", "text", "points, polygons, and lines",
  "tm_basemap()", "tile" , "",
  "tm_tiles()", "tile", ""
)
layers_extended_df = tibble::tribble(
  ~Function, ~Element, ~Geometry,
  "tm_borders()", "polygons (borders)", "polygons",
  "tm_fill()", "polygons (fill)", "polygons",
  "tm_bubbles()", "bubbles", "points, polygons, and lines",
  "tm_dots()", "dots", "points, polygons, and lines",
  "tm_markers()", "marker symbols", "points, polygons, and lines",
  "tm_square()", "squares", "points, polygons, and lines",
  "tm_iso()", "lines with text labels", "lines",
  "tm_rgb()/tm_rgba()", "raster (RGB image)", "raster"
)
layers_df = rbind(layers_basic_df, 
                  layers_extended_df)
```

\@ref(tab:layers-table)

```{r layers-table, echo=FALSE, warning=FALSE}
library(magrittr)
library(kableExtra)
options(kableExtra.html.bsTable = TRUE)
knitr::kable(layers_df, 
             caption = "Map layers.",
             caption.short = "Map layers.",
             booktabs = TRUE) %>%
  kableExtra::kable_styling("striped",
                            latex_options = "striped", 
                            full_width = FALSE) %>% 
  kableExtra::column_spec(1, bold = TRUE, monospace = TRUE) %>% 
  kableExtra::pack_rows("Basic functions", 1, 7) %>%
  kableExtra::pack_rows("Derived functions", 8, 15)
```

<!--JN: Idea - also add a simple viz showing different kind of layers here (visual summary)-->

In this chapter, we focus on what map layers are available in **tmap** and how they differ.
Chapter \@ref(visual-variables), on the other hand, is all about how to present information given in variables using colors, sizes, and shapes.
<!-- ... -->

## Polygons

<!-- intro -->

```{r, warning=FALSE, message=FALSE}
# replace this data with some new tmap dataset
library(tmap)
library(sf)
file_path = system.file("shapes/world.gpkg", package = "spData")
x = read_sf(file_path)
x = st_transform(x, 8857)
```

The main function to visualize polygons is `tm_polygons()`.
By default, it plots areas of polygons in light gray (`gray85`) and polygons borders in slightly dark gray (`gray40`).
<!--JN: where can I find the actual default color values in the code?-->

```{r, eval=FALSE}
tm_shape(x) +
  tm_polygons()
```

Both, colors of areas (polygons' fillings) and colors of borders can be modified using the `col` and `border.col` arguments (Figure \@ref(fig:tmpolygonsder):A).

```{r, eval=FALSE}
tm_shape(x) +
  tm_polygons(col = "lightblue", 
              border.col = "black", lwd = 0.5, lty = "dashed")
```

In fact, `tm_polygons()` is a combination of two separate functions - `tm_fill()` and `tm_borders()`.
The `tm_fill()` function fills polygons with a fixed color or a color palette representing a selected variable (Figure \@ref(fig:tmpolygonsder):B).

```{r, eval=FALSE}
tm_shape(x) +
  tm_fill(col = "lightblue")
```

The `tm_borders()` function draws the borders of the polygons only (Figure \@ref(fig:tmpolygonsder):C).
It allows to change the colors of borders, their widths, or the lines type.

```{r, eval=FALSE}
tm_shape(x) +
  tm_borders(col = "black", lwd = 0.5, lty = "dashed")
```

Notice that we have used the `col` argument in `tm_borders()`, but `border.col` in `tm_polygons()`.
This is necessary to distinguish between the setting of the fillings color and the borders' color.

```{r tmpolygonsder, warning=FALSE, fig.cap="Example of a map created with: (A) 'tm_polygons()' ,  (B) 'tm_fill()' , (C) 'tm_borders()' .", echo=FALSE}
tmpa0 = tm_shape(x) +
  tm_polygons(col = "lightblue", 
              border.col = "black", lwd = 0.5, lty = "dashed") +
  tm_layout(title = "A")
tmpa1 = tm_shape(x) +
  tm_fill(col = "lightblue") +
  tm_layout(title = "B")
tmpa2 = tm_shape(x) +
  tm_borders(col = "black", lwd = 0.5, lty = "dashed") +
  tm_layout(title = "C")
tmap_arrange(tmpa0, tmpa1, tmpa2, ncol = 1)
```

More information on colors, and how they can be applied and modified is explained in detail in Chapter \@ref(colors).

## Symbols

```{r}
data("metro", package = "tmap")
# to update later
set.seed(222)
metro2 = metro[sample(1:nrow(metro), 30), ]
```

Symbols are a very flexible layer type. 
They are usually used to represent point data, but can be also used for lines and polygons.
In the latter cases, they are located in centroid coordinates of each feature.
Their flexibility is also related to the ways symbols can be visualized - it is possible to show values of a given variable by colors of symbols, their sizes, or shapes (more about that is explained in Chapter \@ref(visual-variables).

The `tm_symbols()` is the main function in **tmap** allowing to use and modify symbol elements (Figure \@ref(fig:tmsymbols1)).
By default, this function draws a gray circle symbol with a black border for each element of an input feature.

```{r tmsymbols1, warning=FALSE, fig.cap="A map showing the default tmap symbols.", echo=FALSE, asp=0.25}
tm_shape(metro2) +
  tm_symbols()
```

In the above example, each symbol is related to one feature (row) in the `metro2` object.
However, in a case when we provide multi-element features (such as MULTIPOINT; section \@ref(vector-data-model)), each multi-element object is first split into a number of single-element features and then plotted.

The `tm_symbols()` is a very flexible function with a large number of arguments.
While this allows adjusting its results to almost any need, it also makes this function complicated.
Therefore, four additional layers are implemented in **tmap**: `tm_squares()`, `tm_bubbles()`, `tm_dots()`, `tm_markers()`.
All of them use `tm_symbols()`, but with different default values.

`tm_squares()` uses square symbols (`shape = 22`) instead of circles (`shapes = 21`) (Figure \@ref(fig:tmsymbols2):A).
<!--scale is 4/3 instead of 1-->

```{r, eval=FALSE}
tm_shape(metro2) +
  tm_squares()
```

<!-- JN: what is the main difference between symbols and bubbles?? -->
(Figure \@ref(fig:tmsymbols2):B)

```{r, eval=FALSE}
tm_shape(metro2) +
  tm_bubbles()
```

The main role of `tm_dots()` is to present many locations at the same time.
To do this, this layer has a small size value (`0.02`) at the default (Figure \@ref(fig:tmsymbols2):C).

```{r, eval=FALSE}
tm_shape(metro2) +
  tm_dots()
```

The last additional layer is `tm_markers()`, which uses a marker icon by default (Figure \@ref(fig:tmsymbols2):D).

```{r, eval=FALSE}
tm_shape(metro2) +
  tm_markers()
```

```{r tmsymbols2, warning=FALSE, fig.cap="Maps showing default visualizations using: (A) tm_squares(), (B), tm_bubbles() (C), tm_dots() (D) tm_markers().", echo=FALSE}
tm_ma1 = tm_shape(metro2) +
  tm_squares() +
  tm_layout(title = "A")
tm_ma2 = tm_shape(metro2) +
  tm_bubbles() +
  tm_layout(title = "B")
tm_ma3 = tm_shape(metro2) +
  tm_dots() +
  tm_layout(title = "C")
tm_ma4 = tm_shape(metro2) +
  tm_markers() +
  tm_layout(title = "D")
tmap_arrange(tm_ma1, tm_ma2, tm_ma3, tm_ma4, ncol = 2)
```


## Lines

```{r}
# replace dataset later
library(tmap)
data("rivers", package = "tmap")
```

The `tm_lines()` function allows to visualize different types of line data.

```{r}
tm_shape(rivers) + 
  tm_lines()
```

Lines can be presented using different colors, widths, or types (Chapter \@ref(visual-variables)).
This allows to show a hierarchy (for example, increased line widths for higher capacity roads) or distinguish between types of objects (for example, blue rivers comparing to gray roads).

Lines are also often presented together with text labels (Section \@ref(text)).
One example is an isopleth - a line drawn on a map through all points having the same value of a given variable, such as atmospheric pressure or elevation.
Isopleths can be created with the `tm_iso()` function.

```{r}
# data(land, package = "tmap")
# library(raster)
# elev = land["elevation"]
# elev_isopleths = rasterToContour(as(elev, "Raster"))

# think about tm_iso example
# improve example
# tm_shape(elev_isopleths) +
#   tm_iso()
# 
# library(tmap)
# data("dem", package = "spDataLarge")
# # create hillshade
# hs = hillShade(slope = terrain(dem, "slope"), aspect = terrain(dem, "aspect"))
# # create contour
# cn = rasterToContour(dem)
# 
# tm_shape(hs) +
# 	tm_grid() +
# 	tm_raster(palette = gray(0:100 / 100), n = 100, legend.show = FALSE) +
# 	tm_shape(dem) +
# 	tm_raster(alpha = 0.5, palette = terrain.colors(25),
# 	          legend.show = FALSE) +
# 	tm_shape(cn) +
# 	tm_lines(col = "white") +
# 	tm_text("level", col = "white")
```

## Text

```{r}
tm_shape(metro2) +
  tm_text(text = "name", size = "pop2020") +
  tm_layout(legend.outside = TRUE)
```

## Raster

```{r}
data(land, package = "tmap")
```

```{r}
tm_shape(land[3]) +
  tm_raster()
```

```{r}
tm_shape(land) +
  tm_raster()
```

## Tile

## Combining layers

<!-- or maybe start with it and explain the details later? -->

<!-- show symbols on top of polygons-->
<!-- think of a better example -->
```{r}
tm_shape(x) +
  tm_polygons(col = "gdpPercap") +
  tm_symbols(col = "lifeExp")
```

